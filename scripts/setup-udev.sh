#!/bin/bash
# setup-udev.sh
#
# Setup udev rules for P2P USB Server to allow non-root USB access
# This script manages /etc/udev/rules.d/99-p2p-usb.rules

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Configuration
RULES_FILE="/etc/udev/rules.d/99-p2p-usb.rules"
GROUP_NAME="p2p-usb"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_header() {
    echo -e "${BLUE}$1${NC}"
}

usage() {
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "Commands:"
    echo "  install     Install udev rules (requires sudo)"
    echo "  uninstall   Remove udev rules (requires sudo)"
    echo "  status      Check if rules are installed (no sudo required)"
    echo ""
    echo "Options for install:"
    echo "  --permissive    Use MODE=0666 instead of group-based access"
    echo "  --no-group      Skip group creation (use existing group)"
    echo "  --group NAME    Use custom group name (default: p2p-usb)"
    echo ""
    echo "Examples:"
    echo "  sudo $0 install              # Install with group-based access"
    echo "  sudo $0 install --permissive # Install with world-readable access"
    echo "  sudo $0 uninstall            # Remove rules and optionally group"
    echo "  $0 status                    # Check installation status"
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        print_error "This command must be run with sudo"
        echo "Usage: sudo $0 $1"
        exit 1
    fi
}

generate_rules_group() {
    local group="$1"
    cat << EOF
# P2P USB Server udev rules
# Generated by setup-udev.sh
# https://github.com/rust-p2p-usb/rust-p2p-usb
#
# These rules allow members of the '$group' group to access USB devices
# without requiring root privileges.

# ============================================================================
# USB Device Access (General)
# ============================================================================
# Allow group access to all USB devices via /dev/bus/usb/
SUBSYSTEM=="usb", MODE="0660", GROUP="$group"

# Allow access to USBFS devices
SUBSYSTEM=="usbmisc", MODE="0660", GROUP="$group"

# ============================================================================
# Common USB Device Classes
# ============================================================================

# HID Devices (keyboards, mice, game controllers)
SUBSYSTEM=="usb", ATTR{bDeviceClass}=="03", MODE="0660", GROUP="$group"

# Mass Storage Devices (USB drives, card readers)
SUBSYSTEM=="usb", ATTR{bDeviceClass}=="08", MODE="0660", GROUP="$group"

# Hub Devices
SUBSYSTEM=="usb", ATTR{bDeviceClass}=="09", MODE="0660", GROUP="$group"

# CDC Devices (serial adapters, modems)
SUBSYSTEM=="usb", ATTR{bDeviceClass}=="02", MODE="0660", GROUP="$group"

# Audio Devices
SUBSYSTEM=="usb", ATTR{bDeviceClass}=="01", MODE="0660", GROUP="$group"

# Video Devices (webcams)
SUBSYSTEM=="usb", ATTR{bDeviceClass}=="0e", MODE="0660", GROUP="$group"

# Printer Devices
SUBSYSTEM=="usb", ATTR{bDeviceClass}=="07", MODE="0660", GROUP="$group"

# Vendor Specific Devices (many devices use this)
SUBSYSTEM=="usb", ATTR{bDeviceClass}=="ff", MODE="0660", GROUP="$group"

# ============================================================================
# Virtual Host Controller Interface (vhci_hcd) - Client-side
# ============================================================================
# Allow access to vhci_hcd for attaching virtual USB devices
KERNEL=="vhci_hcd*", MODE="0660", GROUP="$group"
SUBSYSTEM=="platform", KERNEL=="vhci_hcd*", MODE="0660", GROUP="$group"

# Allow access to vhci sysfs entries
# Note: sysfs permissions may require additional configuration
ACTION=="add", SUBSYSTEM=="platform", KERNEL=="vhci_hcd*", RUN+="/bin/chmod 0660 /sys/devices/platform/vhci_hcd.0/attach"
ACTION=="add", SUBSYSTEM=="platform", KERNEL=="vhci_hcd*", RUN+="/bin/chmod 0660 /sys/devices/platform/vhci_hcd.0/detach"
ACTION=="add", SUBSYSTEM=="platform", KERNEL=="vhci_hcd*", RUN+="/bin/chgrp $group /sys/devices/platform/vhci_hcd.0/attach"
ACTION=="add", SUBSYSTEM=="platform", KERNEL=="vhci_hcd*", RUN+="/bin/chgrp $group /sys/devices/platform/vhci_hcd.0/detach"

# ============================================================================
# Device-Specific Rules (Uncomment and modify as needed)
# ============================================================================
# Example: Allow specific device by VID:PID
# SUBSYSTEM=="usb", ATTR{idVendor}=="1234", ATTR{idProduct}=="5678", MODE="0660", GROUP="$group"

# Example: Label for easy identification
# SUBSYSTEM=="usb", ATTR{idVendor}=="1234", ATTR{idProduct}=="5678", SYMLINK+="mydevice"
EOF
}

generate_rules_permissive() {
    cat << 'EOF'
# P2P USB Server udev rules (Permissive Mode)
# Generated by setup-udev.sh
# https://github.com/rust-p2p-usb/rust-p2p-usb
#
# WARNING: These rules allow ALL users to access USB devices.
# This is less secure but simpler to configure.

# ============================================================================
# USB Device Access (General) - World Readable/Writable
# ============================================================================
# Allow all users to access USB devices via /dev/bus/usb/
SUBSYSTEM=="usb", MODE="0666"

# Allow access to USBFS devices
SUBSYSTEM=="usbmisc", MODE="0666"

# ============================================================================
# Virtual Host Controller Interface (vhci_hcd) - Client-side
# ============================================================================
KERNEL=="vhci_hcd*", MODE="0666"
SUBSYSTEM=="platform", KERNEL=="vhci_hcd*", MODE="0666"

# Allow access to vhci sysfs entries
ACTION=="add", SUBSYSTEM=="platform", KERNEL=="vhci_hcd*", RUN+="/bin/chmod 0666 /sys/devices/platform/vhci_hcd.0/attach"
ACTION=="add", SUBSYSTEM=="platform", KERNEL=="vhci_hcd*", RUN+="/bin/chmod 0666 /sys/devices/platform/vhci_hcd.0/detach"
EOF
}

create_group() {
    local group="$1"
    local user="${SUDO_USER:-$USER}"

    if getent group "$group" > /dev/null 2>&1; then
        print_info "Group '$group' already exists"
    else
        print_info "Creating group '$group'..."
        groupadd "$group"
        print_info "Group '$group' created"
    fi

    if [ -n "$user" ] && [ "$user" != "root" ]; then
        if id -nG "$user" | grep -qw "$group"; then
            print_info "User '$user' is already a member of '$group'"
        else
            print_info "Adding user '$user' to group '$group'..."
            usermod -aG "$group" "$user"
            print_warn "You need to log out and back in for group membership to take effect"
            print_warn "Alternatively, run: newgrp $group"
        fi
    fi
}

remove_group() {
    local group="$1"

    if ! getent group "$group" > /dev/null 2>&1; then
        print_info "Group '$group' does not exist"
        return 0
    fi

    echo ""
    read -p "Remove group '$group'? [y/N] " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        print_info "Removing group '$group'..."
        groupdel "$group" 2>/dev/null || print_warn "Could not remove group (may have active sessions)"
    else
        print_info "Keeping group '$group'"
    fi
}

reload_udev() {
    print_info "Reloading udev rules..."
    udevadm control --reload-rules
    udevadm trigger
    print_info "udev rules reloaded"
}

cmd_install() {
    check_root "install"

    local permissive=false
    local create_grp=true
    local group="$GROUP_NAME"

    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --permissive)
                permissive=true
                shift
                ;;
            --no-group)
                create_grp=false
                shift
                ;;
            --group)
                group="$2"
                shift 2
                ;;
            *)
                print_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    print_header "Installing P2P USB udev rules..."
    echo ""

    # Check for existing rules
    if [ -f "$RULES_FILE" ]; then
        print_warn "Existing rules found at $RULES_FILE"
        read -p "Overwrite existing rules? [y/N] " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Installation cancelled"
            exit 0
        fi
    fi

    # Create group if using group-based access
    if [ "$permissive" = false ] && [ "$create_grp" = true ]; then
        create_group "$group"
        echo ""
    fi

    # Generate and install rules
    print_info "Installing udev rules to $RULES_FILE..."
    if [ "$permissive" = true ]; then
        generate_rules_permissive > "$RULES_FILE"
        print_warn "Installed PERMISSIVE rules (MODE=0666)"
        print_warn "This is less secure - consider using group-based access"
    else
        generate_rules_group "$group" > "$RULES_FILE"
        print_info "Installed group-based rules (GROUP=$group, MODE=0660)"
    fi

    # Set file permissions
    chmod 644 "$RULES_FILE"

    # Reload rules
    reload_udev

    echo ""
    print_info "Installation complete!"
    echo ""
    echo "------------------------------------------------------------"
    echo "Next steps:"
    echo ""
    if [ "$permissive" = false ]; then
        echo "  1. Log out and back in for group membership to take effect"
        echo "     (or run: newgrp $group)"
        echo ""
        echo "  2. Verify group membership:"
        echo "     groups"
        echo ""
        echo "  3. Replug USB devices or run:"
        echo "     sudo udevadm trigger"
        echo ""
    else
        echo "  1. Replug USB devices or run:"
        echo "     sudo udevadm trigger"
        echo ""
    fi
    echo "  Check status with: $0 status"
    echo "------------------------------------------------------------"
}

cmd_uninstall() {
    check_root "uninstall"

    print_header "Uninstalling P2P USB udev rules..."
    echo ""

    if [ ! -f "$RULES_FILE" ]; then
        print_warn "No rules file found at $RULES_FILE"
        print_info "Nothing to uninstall"
        exit 0
    fi

    # Remove rules file
    print_info "Removing $RULES_FILE..."
    rm -f "$RULES_FILE"

    # Reload rules
    reload_udev

    # Optionally remove group
    remove_group "$GROUP_NAME"

    echo ""
    print_info "Uninstallation complete!"
    echo ""
    echo "------------------------------------------------------------"
    echo "USB devices will require root access again after replug."
    echo "To restore access, run: sudo udevadm trigger"
    echo "------------------------------------------------------------"
}

cmd_status() {
    print_header "P2P USB udev Rules Status"
    echo ""

    # Check rules file
    echo "Rules file: $RULES_FILE"
    if [ -f "$RULES_FILE" ]; then
        echo -e "  Status: ${GREEN}INSTALLED${NC}"
        echo "  Size: $(stat -c%s "$RULES_FILE" 2>/dev/null || echo "unknown") bytes"
        echo "  Modified: $(stat -c%y "$RULES_FILE" 2>/dev/null | cut -d'.' -f1 || echo "unknown")"

        # Detect mode
        if grep -q 'MODE="0666"' "$RULES_FILE" 2>/dev/null; then
            echo -e "  Mode: ${YELLOW}PERMISSIVE${NC} (MODE=0666)"
        else
            local group
            group=$(grep -oP 'GROUP="\K[^"]+' "$RULES_FILE" 2>/dev/null | head -1 || echo "unknown")
            echo -e "  Mode: ${GREEN}GROUP-BASED${NC} (GROUP=$group)"
        fi
    else
        echo -e "  Status: ${YELLOW}NOT INSTALLED${NC}"
    fi
    echo ""

    # Check group
    echo "Group: $GROUP_NAME"
    if getent group "$GROUP_NAME" > /dev/null 2>&1; then
        echo -e "  Status: ${GREEN}EXISTS${NC}"
        local members
        members=$(getent group "$GROUP_NAME" | cut -d: -f4)
        if [ -n "$members" ]; then
            echo "  Members: $members"
        else
            echo "  Members: (none)"
        fi

        # Check if current user is member
        local current_user="${SUDO_USER:-$USER}"
        if id -nG "$current_user" 2>/dev/null | grep -qw "$GROUP_NAME"; then
            echo -e "  Current user ($current_user): ${GREEN}MEMBER${NC}"
        else
            echo -e "  Current user ($current_user): ${YELLOW}NOT A MEMBER${NC}"
        fi
    else
        echo -e "  Status: ${YELLOW}DOES NOT EXIST${NC}"
    fi
    echo ""

    # Check vhci_hcd module (client-side)
    echo "vhci_hcd module (USB/IP client):"
    if lsmod 2>/dev/null | grep -q vhci_hcd; then
        echo -e "  Status: ${GREEN}LOADED${NC}"

        # Check sysfs permissions
        local attach_file="/sys/devices/platform/vhci_hcd.0/attach"
        if [ -f "$attach_file" ]; then
            local perms
            perms=$(stat -c%a "$attach_file" 2>/dev/null)
            local owner_group
            owner_group=$(stat -c%G "$attach_file" 2>/dev/null)
            echo "  Attach file: $attach_file"
            echo "    Permissions: $perms"
            echo "    Group: $owner_group"
        fi
    else
        echo -e "  Status: ${YELLOW}NOT LOADED${NC}"
        echo "  To load: sudo modprobe vhci-hcd"
    fi
    echo ""

    # Check USB device access
    echo "USB device access (/dev/bus/usb):"
    if [ -d "/dev/bus/usb" ]; then
        # Find first USB device
        local usb_dev
        usb_dev=$(find /dev/bus/usb -type c 2>/dev/null | head -1)
        if [ -n "$usb_dev" ]; then
            local perms
            perms=$(stat -c%a "$usb_dev" 2>/dev/null)
            local owner_group
            owner_group=$(stat -c%G "$usb_dev" 2>/dev/null)
            echo "  Example device: $usb_dev"
            echo "    Permissions: $perms"
            echo "    Group: $owner_group"

            # Test actual access
            local current_user="${SUDO_USER:-$USER}"
            if [ "$EUID" -eq 0 ]; then
                echo "    Access test: (running as root, skipped)"
            elif [ -r "$usb_dev" ] && [ -w "$usb_dev" ]; then
                echo -e "    Access test: ${GREEN}READ/WRITE OK${NC}"
            elif [ -r "$usb_dev" ]; then
                echo -e "    Access test: ${YELLOW}READ ONLY${NC}"
            else
                echo -e "    Access test: ${RED}NO ACCESS${NC}"
            fi
        else
            echo "  No USB devices found"
        fi
    else
        echo -e "  Status: ${RED}/dev/bus/usb not found${NC}"
    fi
}

# Main
case "${1:-}" in
    install)
        shift
        cmd_install "$@"
        ;;
    uninstall)
        cmd_uninstall
        ;;
    status)
        cmd_status
        ;;
    -h|--help|help)
        usage
        ;;
    "")
        usage
        exit 1
        ;;
    *)
        print_error "Unknown command: $1"
        usage
        exit 1
        ;;
esac
